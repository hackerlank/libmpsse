# -*- coding: GB18030 -*-

from mpsse import *
from time import sleep
from ziku import *

#/*************************************************
#名    称：LCD12864_ST7920串行测试程序
#试验功能：测试基于ST7920控制芯片的LCD12864的显示
          #串行方式连接；晶振11.0592M
#编    写：JiangX.net
#python改编：kamijawa@gmail.com
#*************************************************/

##include <reg52.h>
##include <ziku.h>
##include <intrins.h>
##define uchar unsigned char
##define uint unsigned int    //宏定义

#/*****LCD接口定义*****/
#sbit CS  = P2^0;      //片选信号
#sbit SID = P2^1;      //串行数据
#sbit SCLK = P2^2;      //串行同步时钟
#sbit PSB = P2^3;        //串并口选择 1:并口模式; 0:串口模式;

CS = GPIOL0  #D4->RS
SID = GPIOL1  #D5->RW
SCLK = GPIOL2  #D6->E

#/*****LCD功能初始化指令*****/
##define CLEAR_SCREEN 0x01   //清屏指令：清屏且AC值为00H
##define AC_INIT   0x02   //将AC设置为00H。且游标移到原点位置
##define CURSE_ADD  0x06   //设定游标移到方向及图像整体移动方向（默认游标右移，图像整体不动）
##define FUN_MODE  0x30   //工作模式：8位基本指令集
##define DISPLAY_ON  0x0c   //显示开,显示游标，且游标位置反白
##define DISPLAY_OFF  0x08   //显示关
##define CURSE_DIR  0x14   //游标向右移动:AC=AC+1
##define SET_CG_AC  0x40   //设置AC，范围为：00H~3FH
##define SET_DD_AC  0x80

CLEAR_SCREEN = 0x01   #清屏指令：清屏且AC值为00H
AC_INIT   = 0x02   #将AC设置为00H。且游标移到原点位置
CURSE_ADD =  0x06   #设定游标移到方向及图像整体移动方向（默认游标右移，图像整体不动）
FUN_MODE =  0x30   #工作模式：8位基本指令集
DISPLAY_ON =  0x0c   #显示开,显示游标，且游标位置反白
DISPLAY_OFF =  0x08   #显示关
CURSE_DIR =  0x14   #游标向右移动:AC=AC+1
SET_CG_AC =  0x40   #设置AC，范围为：00H~3FH
SET_DD_AC =  0x80


#/*****汉字地址表*****/
#uchar code addr_tab[]={
#0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,//第一行汉字位置
#0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,//第二行汉字位置
#0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,//第三行汉字位置
#0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,//第四行汉字位置
#};

addr_tab = [
    [0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87],
    [0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97],
    [0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f],
    [0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f]
]

#在python中对输入i(i<256)做左移n位操作
def leftshift(i, n=1):
    bstr = bin(i)
    s = bstr[2:]
    s = s[-8:]
    while len(s) < 8:
        s = '0' + s
    #print(s)
    return int(s[0]), int('0b' + s[n:] + '0' * n, 2)


#/*****n（ms）延时子程序*****/
#void delayms(uint t)     //约延时n（ms）
#{
    #uint i;
    #while(t--)
    #{
        #for(i=0;i<125;i++);
    #}       
#}
def delayms(t):
    sleep(t/1000.0)

#/*****串行发送一个字节*****/
#void SendByte(uchar Dbyte)
#{
    #uchar i;
    #for(i=0;i<8;i++)
    #{
        #SCLK = 0;
        #Dbyte=Dbyte<<1;        //左移一位
        #SID = CY;              //移出的位给SID
        #SCLK = 1;
        #SCLK = 0;
    #}
#}
def  SendByte(Dbyte):
    for i in range(8):
        io.PinLow(SCLK)
        #Dbyte=Dbyte<<1;        #左移一位
        CY, Dbyte = leftshift(Dbyte)
        if CY==0:
            io.PinLow(SID)
        else:
            io.PinHigh(SID)
        #SID = CY;              #移出的位给SID
        io.PinHigh(SCLK)
        io.PinLow(SCLK)
    




#/*****串行接收一个字节*****/
#uchar ReceiveByte(void)
#{
    #uchar i,temp1,temp2;
    #temp1 = 0;
    #temp2 = 0;
    #for(i=0;i<8;i++)
    #{
        #temp1=temp1<<1;
        #SCLK = 0;
        #SCLK = 1;           
        #SCLK = 0;
        #if(SID) temp1++;
    #}
    #for(i=0;i<8;i++)
    #{
        #temp2=temp2<<1;
        #SCLK = 0;
        #SCLK = 1;
        #SCLK = 0;
        #if(SID) temp2++;
    #}
    #return ((0xf0&temp1)+(0x0f&temp2));
#}
def ReceiveByte():
    temp1 = 0
    temp2 = 0
    for i in range(8):
        v, temp1=leftshift(temp1)
        io.PinLow(SCLK)
        io.PinHigh(SCLK)
        io.PinLow(SCLK)
        if(io.PinState(SID)==1):
            temp1 += 1
    for i in range(8):
        v, temp2=leftshift(temp2)
        io.PinLow(SCLK)
        io.PinHigh(SCLK)
        io.PinLow(SCLK)
        if(io.PinState(SID)==1):
            temp2 += 1
    return ((0xf0&temp1)+(0x0f&temp2))


#/*****检测LCD忙状态*****/
#void CheckBusy( void )
#{
    #do   SendByte(0xfc);         //11111,RW(1),RS(0),0
    #while(0x80&ReceiveByte());       //BF(.7)=1 Busy
#}
def CheckBusy():
    SendByte(0xfc)
    while (0x80&ReceiveByte())>0:
        #SendByte(0xfc)
        pass
    


#/*****写指令*****/
#void Lcd_WriteCmd(uchar Cbyte )
#{
    #CS = 1;
    #CheckBusy();
    #SendByte(0xf8);              //11111,RW(0),RS(0),0
    #SendByte(0xf0&Cbyte);        //高四位
    #SendByte(0xf0&Cbyte<<4);   //低四位(先执行<<)
    #CS = 0;
#}

def Lcd_WriteCmd(Cbyte):
    io.PinHigh(CS)
    CheckBusy()
    SendByte(0xf8)             
    SendByte(0xf0&Cbyte)
    v, Cbyte = leftshift(Cbyte, 4)
    SendByte(0xf0&Cbyte)  
    io.PinLow(CS)



#/*****写数据*****/
#void Lcd_WriteData(uchar Dbyte )
#{
    #CS = 1;
    #CheckBusy();
    #SendByte(0xfa);              //11111,RW(0),RS(1),0
    #SendByte(0xf0&Dbyte);        //高四位
    #SendByte(0xf0&Dbyte<<4);   //低四位(先执行<<)
    #CS = 0;
#}
def Lcd_WriteData(Dbyte):
    io.PinHigh(CS)
    CheckBusy()
    SendByte(0xfa)              
    SendByte(0xf0&Dbyte)
    v, Dbyte = leftshift(Dbyte, 4)
    SendByte(0xf0&Dbyte)   
    io.PinLow(CS)


#/*****初始化LCD*****/
#void Lcd_Init(void)
#{
    #PSB = 0;
    #delayms(50);
    #Lcd_WriteCmd(0x30);        //选择基本指令集
    #delayms(1);
    #Lcd_WriteCmd(0x30);          //选择8bit数据流
    #delayms(1);
    #Lcd_WriteCmd(0x0c);          //开显示(无游标、不反白)
    #delayms(1);
    #Lcd_WriteCmd(0x01);          //清除显示，并且设定地址指针为00H
    #delayms(20);
#}
def Lcd_Init():
    #PSB = 0;
    delayms(50)
    Lcd_WriteCmd(0x30)       #选择基本指令集
    delayms(1)
    Lcd_WriteCmd(0x30)       #选择8bit数据流
    delayms(1)
    Lcd_WriteCmd(0x0c)       #开显示(无游标、不反白)
    delayms(1)
    Lcd_WriteCmd(0x01)       #清除显示，并且设定地址指针为00H
    delayms(20)





#/*****显示汉字*****/
#void hanzi_Disp(uchar x,uchar y,uchar code *s)
#{
    #Lcd_WriteCmd(addr_tab[8*x+y]);  //写地址
    #while(*s>0)
    #{ 
        #Lcd_WriteData(*s);    //写数据
        #s++;    
    #}
#}
def hanzi_Disp(x,y,s):
    Lcd_WriteCmd(addr_tab[x][y])  #写地址
    arr = bytearray(s)
    for i in arr:
        Lcd_WriteData(i)    #写数据

#/*****显示图片（显示Gdram内容）*****/

#/*绘图显示的步骤
#1 关闭绘图显示功能
#2 先将垂直的坐标(Y)写入绘图RAM地址
#3 再将水平的位元组坐标(X)写入绘图RAM地址
#4 将D15－D8写入RAM中
#5 将D7－D0写入到RAM中
#6 打开绘图显示功能*/

#//图片取模方式：横向取模，字节正序
#void pic_Disp(uchar *pic)    //显示Gdram内容（显示图片）
#{
    #uchar x,y,i;
    #for(i=0;i<9;i=i+8)
    #for(y=0;y<32;y++)
    #{
        #for(x=0;x<8;x++)
        #{
            #Lcd_WriteCmd(0x36);   //扩充指令，开绘图显示
            #Lcd_WriteCmd(0x80+y);  //行地址
            #Lcd_WriteCmd(0x80+x+i);  //列地址
            #Lcd_WriteData(*pic++);  //写数据 D15－D8
            #Lcd_WriteData(*pic++);  //写数据 D7－D0
            #Lcd_WriteCmd(0x30);
        #}
    #}
#}
def pic_Disp(pic):    
    pixel = 0
    for i in [0,8]:
        for y in range(32):
            for x in range(8):
                Lcd_WriteCmd(0x36)   
                Lcd_WriteCmd(0x80+y) 
                Lcd_WriteCmd(0x80+x+i)  
                Lcd_WriteData(pic[pixel])
                pixel += 1
                Lcd_WriteData(pic[pixel])
                pixel += 1
                Lcd_WriteCmd(0x30)
            
        





#/*****整屏显示竖条*****/
#//当i=0时显示上面128×32,当i=8时显示下面128×32
#//当i=0时显示上面128×32,当i=8时显示下面128×32
#void LcdFill_Vertical()
#{ 
    #uchar x,y,i;
    #for(i=0;i<9;i=i+8)  
    #for(y=0;y<0x20;y++)
    #{    
        #for(x=0;x<8;x++)
        #{
            #Lcd_WriteCmd(0x36);   //扩充指令 绘图显示
            #Lcd_WriteCmd(y+0x80);       //行地址
            #Lcd_WriteCmd(x+0x80+i);     //列地址    
            #Lcd_WriteData(0x55);   //写数据 D15－D8
            #Lcd_WriteData(0x55);   //写数据 D7－D0 
            #Lcd_WriteCmd(0x30);
        #}
    #}
#}
def LcdFill_Vertical():
    for i in [0,8]:  
        for y in range(32):
            for x in range(8):
                Lcd_WriteCmd(0x36)
                Lcd_WriteCmd(y+0x80)
                Lcd_WriteCmd(x+0x80+i)
                Lcd_WriteData(0x55)
                Lcd_WriteData(0x55)
                Lcd_WriteCmd(0x30)

#/*****整屏显示横条*****/
#void LcdFill_Level()
#{
    #uchar x,y,i;
    #uchar k;  
    #for(i=0;i<9;i+=8)   
    #for(y=0;y<0x20;y++)
    #{    
        #if((y%2)==1) k=0xff;
        #else k=0;
        #for(x=0;x<8;x++)
        #{ 
            #Lcd_WriteCmd(0x36);   //扩充指令 绘图显示
            #Lcd_WriteCmd(y+0x80); //行地址
            #Lcd_WriteCmd(x+0x80+i); //列地址           
            #Lcd_WriteData(k);
            #Lcd_WriteData(k);
            #Lcd_WriteCmd(0x30);
        #}
    #}    
#}
def LcdFill_Level():
    for i in [0,8]:
        for y in range(32):
            if((y%2)==1):
                k=0xff
            else:
                k=0
            for x in range(8):
                Lcd_WriteCmd(0x36)
                Lcd_WriteCmd(y+0x80)
                Lcd_WriteCmd(x+0x80+i)
                Lcd_WriteData(k)
                Lcd_WriteData(k)
                Lcd_WriteCmd(0x30)


#/*****整屏充满亮点或暗点*****/
#//当i=0时显示上面128×32,当i=8时显示下面128×32
#//当i=0时显示上面128×32,当i=8时显示下面128×32
#void Lcd_Fill(uchar test)
#{ 
    #uchar x,y,i;
    #for(i=0;i<9;i=i+8)  
    #for(y=0;y<0x20;y++)
    #{    
        #for(x=0;x<8;x++)
        #{
            #Lcd_WriteCmd(0x36);   //扩充指令 绘图显示
            #Lcd_WriteCmd(y+0x80);       //行地址
            #Lcd_WriteCmd(x+0x80+i);     //列地址    
            #Lcd_WriteData(test);   //写数据 D15－D8
            #Lcd_WriteData(test);   //写数据 D7－D0 
            #Lcd_WriteCmd(0x30);
        #}
    #}
#}

def Lcd_Fill(test):
    for i in [0,8]:
        for y in range(32):
            for x in range(8):
                Lcd_WriteCmd(0x36)
                Lcd_WriteCmd(y+0x80)
                Lcd_WriteCmd(x+0x80+i)
                Lcd_WriteData(test)
                Lcd_WriteData(test)
                Lcd_WriteCmd(0x30)



    



#/*****主函数*****/
#void main(void)
#{
 #Lcd_Init();
 #while(1)
 #{
  #Lcd_Init();
  #hanzi_Disp(0,0,"ST7920型液晶模块");
  #hanzi_Disp(1,1,"串行测试程序");
  #hanzi_Disp(2,0,"www.JiangX.net");
  #hanzi_Disp(3,3,"");
  #delayms(2000);

  #Lcd_Init();
 #// Lcd_Fill(0xff);
  #hanzi_Disp(1,2,"坏点检测");
  #delayms(500);

  #Lcd_Init();
  #Lcd_Fill(0xff);
  #delayms(1500);
  
  #Lcd_Init();
  #LcdFill_Vertical();
  #delayms(750);

  #Lcd_Init();
  #LcdFill_Level();
  #delayms(750);

   #Lcd_Init();
  #hanzi_Disp(1,2,"显示汉字");
  #delayms(500);

  #Lcd_Init();
  #hanzi_Disp(0,0,tangshi);
  #delayms(1500);

   #Lcd_Init();
  #hanzi_Disp(1,2,"显示图片");
  #delayms(500);

  #Lcd_Init();
  #pic_Disp(LCDsheji);
  #delayms(1000);   
  
  #Lcd_Init();
  #pic_Disp(rmb);
  #delayms(1000);

   #Lcd_Init();
  #pic_Disp(qiche);
  #delayms(1000);

   #Lcd_Init();
  #pic_Disp(gongji);
  #delayms(1000);

  #Lcd_Fill(0x00);      //清显示RAM
  #delayms(500);     
  #}
#}

if __name__=="__main__":
    io = MPSSE(GPIO, TWELVE_MHZ)
    Lcd_Init()
    hanzi_Disp(0,0,"ST7920型液晶模块")
    hanzi_Disp(1,1,"串行测试程序")
    hanzi_Disp(2,0,"www.JiangX.net")
    hanzi_Disp(3,3,"")
    delayms(2000)
        
    Lcd_Init()
    #Lcd_Fill(0xff);
    hanzi_Disp(1,2,"坏点检测")
    delayms(500)
  
    Lcd_Init()
    Lcd_Fill(0xff)
    delayms(1500)
    
    Lcd_Init()
    LcdFill_Vertical()
    delayms(750)
  
    Lcd_Init()
    LcdFill_Level()
    delayms(750)
  
    Lcd_Init()
    hanzi_Disp(1,2,"显示汉字")
    delayms(500)
  
    Lcd_Init()
    hanzi_Disp(0,0,tangshi)
    delayms(1500)
  
    Lcd_Init()
    hanzi_Disp(1,2,"显示图片")
    delayms(500)
  
    Lcd_Init()
    pic_Disp(LCDsheji)
    delayms(1000)
    
    Lcd_Init()
    pic_Disp(rmb)
    delayms(1000)
  
    Lcd_Init()
    pic_Disp(qiche)
    delayms(1000)
  
    Lcd_Init()
    pic_Disp(gongji)
    delayms(1000)
  
    Lcd_Fill(0x00)
    delayms(500)
    
    
    io.Close()
